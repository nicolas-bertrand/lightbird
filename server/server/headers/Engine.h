#ifndef ENGINE_H
# define ENGINE_H

# include <QObject>

# include "Request.h"
# include "Response.h"

# include "Client.h"
# include "IOnUnserialize.h"
# include "IOnSerialize.h"

/// @brief The role of the Engine is to execute a request sent by a client,
/// by calling the interfaces of the Api that are implemented by the plugins.
/// The Engine uses massively the signals/slots feature of Qt. This way, the
/// execution of a request can be stopped at any time, if the client is disconnected.
/// The final goal of the engine is to generates a response that can be sent to the
/// client.
class Engine : public QObject
{
    Q_OBJECT

public:
    Engine(Client *client, QObject *parent = 0);
    ~Engine();

    /// @brief This method is called each time new data are available for the Engine.
    /// @param data : The data to process.
    void    read(QByteArray &data);
    /// @brief Tells if the Engine is processing a request.
    bool    isRunning();
    /// @brief Returns the request currently executing by the Engine.
    Streamit::IRequest  &getRequest();
    /// @brief Returns the response currently generated by the Engine.
    Streamit::IResponse &getResponse();
    /// @brief Prepare the Engine so that is can be used to execute an other request.
    void    clear();

private:
    Engine(const Engine &context);
    Engine &operator=(const Engine &context);

    /// @brief List the possible states of the unserialization.
    enum State
    {
        PROTOCOL,   ///< Search the protocol of the request
        HEADER,     ///< Unserializing the header of the request
        CONTENT,    ///< Unserializing the content of the request
        FOOTER      ///< Unserializing the footer of the request
    };

    Client          *client;        ///< The client for which the engine is running.
    QByteArray      data;           ///< The raw data sent by the client, and that will be unserialized to the request.
    Request         request;        ///< The request sent by the client.
    Response        response;       ///< The response generated.
    Engine::State   state;          ///< The current state of the unserialization.
    bool            running;        ///< If the Engine is execution a request.
    bool            done;           ///< True if at least one plugin has implementes one of the IDoUnserialize or the IDoSerialize interfaces.
    bool            needResponse;   ///< If the request of the client needs a response.
    QStringList     protocolUnknow; ///< List the plugins that doesn't know the protocol of the request.

signals:
    // Each signals represents a step of the execution of the request
    void    onProtocol();
    void    doUnserializeHeader();
    void    doUnserializeContent();
    void    doUnserializeFooter();
    void    doExecution();
    void    onExecution();
    void    doSerializeHeader();
    void    doSerializeContent();
    void    doSerializeFooter();

private slots:
    // This methods calls the interfaces implemented by the plugin,
    // in order to execute the request and generate a response.
    void    _onRead(QByteArray &data);
    void    _onProtocol();
    void    _doUnserializeHeader();
    void    _doUnserializeContent();
    void    _doUnserializeFooter();
    void    _onUnserialize(Streamit::IOnUnserialize::Unserialize type);
    void    _doExecution();
    void    _onExecution();
    void    _onSerialize(Streamit::IOnSerialize::Serialize type);
    void    _doSerializeHeader();
    void    _doSerializeContent();
    void    _doSerializeFooter();
    void    _onWrite(QByteArray &data);
    void    _onWrote();
};

#endif // ENGINE_H
